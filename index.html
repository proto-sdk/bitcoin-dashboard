<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/x-icon" href="/bitcoin-dashboard/proto_favicon.ico">
    <link rel="icon" type="image/png" href="/bitcoin-dashboard/proto_logo.png">
    <link rel="icon" type="image/png" href="/bitcoin-dashboard/proto_favicon_32.png">
    <link rel="shortcut icon" type="image/x-icon" href="/bitcoin-dashboard/proto_favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Network Statistics</title>
    <style>
        /* ... (keeping existing styles) ... */
        
        /* Add new styles for interval trend indicator */
        .trend-indicator {
            font-size: 14px;
            margin-left: 8px;
            opacity: 0.8;
        }
        
        .trend-up {
            color: #FF6B6B;
        }
        
        .trend-down {
            color: #00E396;
        }
        
        .trend-stable {
            color: #FEB019;
        }
        
        .interval-details {
            font-size: 12px;
            color: #999;
            margin-top: 4px;
        }
        
        /* Add animation for updating values */
        @keyframes highlight {
            0% { background-color: rgba(255, 107, 53, 0.2); }
            100% { background-color: transparent; }
        }
        
        .highlight {
            animation: highlight 1s ease-out;
        }
    </style>
</head>
<body>
    <!-- ... (keeping existing header and structure) ... -->
    
    <div class="stats-grid">
        <!-- ... (keeping other stat cards) ... -->
        
        <!-- Updated Interval Card -->
        <div class="stat-card" id="intervalCard">
            <div class="status-indicator"></div>
            <span class="stat-icon price-green">⏲️</span>
            <div class="stat-value" id="interval">Loading...</div>
            <div class="stat-label">Block Interval</div>
            <div class="interval-details" id="intervalDetails">Calculating...</div>
            <div class="tooltip">Average time between blocks with trend analysis</div>
        </div>
        
        <!-- ... (keeping other stat cards) ... -->
    </div>

    <!-- ... (keeping footer) ... -->

    <script>
        // Add new interval tracking variables
        let intervalHistory = [];
        let lastIntervalUpdate = Date.now();
        const TARGET_BLOCK_TIME = 600; // 10 minutes in seconds
        
        // Update the fetchData function with improved interval handling
        async function fetchData() {
            try {
                // ... (keeping existing fetch logic) ...
                
                // Enhanced interval fetching logic
                async function fetchBlockInterval() {
                    let interval = null;
                    let source = '';
                    let blockData = null;
                    
                    // Try Blockstream API first (most reliable)
                    try {
                        const response = await fetch('https://blockstream.info/api/blocks/tip');
                        const latestBlock = await response.json();
                        const prevResponse = await fetch(`https://blockstream.info/api/block/${latestBlock.id}`);
                        const prevBlock = await prevResponse.json();
                        
                        if (latestBlock && prevBlock) {
                            interval = latestBlock.timestamp - prevBlock.timestamp;
                            source = 'Blockstream';
                            blockData = {
                                height: latestBlock.height,
                                timestamp: latestBlock.timestamp
                            };
                        }
                    } catch (error) {
                        console.warn('Blockstream API error:', error);
                    }
                    
                    // Fallback to Mempool.space
                    if (!interval) {
                        try {
                            const response = await fetch('https://mempool.space/api/blocks/tip');
                            const latestBlock = await response.json();
                            const prevResponse = await fetch(`https://mempool.space/api/block/${latestBlock.id}`);
                            const prevBlock = await prevResponse.json();
                            
                            if (latestBlock && prevBlock) {
                                interval = latestBlock.timestamp - prevBlock.timestamp;
                                source = 'Mempool.space';
                                blockData = {
                                    height: latestBlock.height,
                                    timestamp: latestBlock.timestamp
                                };
                            }
                        } catch (error) {
                            console.warn('Mempool.space API error:', error);
                        }
                    }
                    
                    // Final fallback to blockchain.info
                    if (!interval) {
                        try {
                            const response = await fetch('https://blockchain.info/latestblock');
                            const data = await response.json();
                            if (data.time) {
                                // Use a 10-minute average if we can't get exact block times
                                interval = 600;
                                source = 'Blockchain.info (estimated)';
                                blockData = {
                                    height: data.height,
                                    timestamp: data.time
                                };
                            }
                        } catch (error) {
                            console.warn('Blockchain.info API error:', error);
                        }
                    }
                    
                    return { interval, source, blockData };
                }
                
                // Fetch and update interval data
                const intervalData = await fetchBlockInterval();
                if (intervalData.interval) {
                    // Update interval history
                    intervalHistory.push({
                        timestamp: Date.now(),
                        interval: intervalData.interval,
                        source: intervalData.source,
                        blockData: intervalData.blockData
                    });
                    
                    // Keep only last 6 intervals (1 hour worth of data assuming 10-min blocks)
                    if (intervalHistory.length > 6) {
                        intervalHistory.shift();
                    }
                    
                    // Calculate trend
                    let trend = 'stable';
                    let trendIcon = '⟷';
                    if (intervalHistory.length > 1) {
                        const avgRecent = intervalHistory.slice(-3).reduce((sum, item) => sum + item.interval, 0) / 3;
                        const avgPrevious = intervalHistory.slice(0, -3).reduce((sum, item) => sum + item.interval, 0) / 3;
                        
                        if (avgRecent > avgPrevious * 1.1) {
                            trend = 'up';
                            trendIcon = '↑';
                        } else if (avgRecent < avgPrevious * 0.9) {
                            trend = 'down';
                            trendIcon = '↓';
                        }
                    }
                    
                    // Format interval display
                    const minutes = Math.floor(intervalData.interval / 60);
                    const seconds = Math.floor(intervalData.interval % 60);
                    const intervalElement = document.getElementById('interval');
                    const oldText = intervalElement.textContent;
                    const newText = `${minutes}m ${seconds}s ${trendIcon}`;
                    
                    // Update display with highlight animation if value changed
                    if (oldText !== newText) {
                        intervalElement.textContent = newText;
                        intervalElement.classList.remove('highlight');
                        void intervalElement.offsetWidth; // Trigger reflow
                        intervalElement.classList.add('highlight');
                    }
                    
                    // Add trend class
                    intervalElement.classList.remove('trend-up', 'trend-down', 'trend-stable');
                    intervalElement.classList.add(`trend-${trend}`);
                    
                    // Update interval details
                    const deviation = ((intervalData.interval - TARGET_BLOCK_TIME) / TARGET_BLOCK_TIME * 100).toFixed(1);
                    const deviationText = deviation > 0 ? `+${deviation}%` : `${deviation}%`;
                    document.getElementById('intervalDetails').textContent = 
                        `${deviationText} from target (10m) • ${intervalData.source}`;
                    
                    // Store for other calculations
                    window.currentInterval = intervalData.interval;
                }
                
                // ... (keeping rest of the fetchData function) ...
                
            } catch (error) {
                console.error('Error in fetchData:', error);
                // ... (keeping error handling) ...
            }
        }
        
        // ... (keeping rest of the script) ...
    </script>
</body>
</html>
